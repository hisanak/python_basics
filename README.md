# Pythonプログラミングの基本

## Anacondaでまとめてインストール
- python3(python): pythonプログラムの実行に必要
- pip3(pip): 世界中の人が書いたプログラムをインストールできる
    - `pip install hoge --user`でhogeという名前のパッケージをインストールする
- conda: パッケージ管理を複雑に行うことができる
- jupyter: Webブラウザを使ってリッチなプログラミング環境
    - コードの一部を実行してデバッグをして、ということが簡単
    - 大規模なコーディングになるとVSCodeでいいじゃんという話もある

## プログラムの書き方
- インタラクティブな実行： `$ python`と打って始める
- コマンドラインからの実行： `$ python hoge.py`と打って実行
- Jupyterでコードを区切りながら実行： エクスプローラなどで`jupyter notebook`と打つと始まる

## いろんな書き方≠モジュールの使い方
- [シンプルなプログラム](1_fizzbuzz)
    - fizzbuzz.pyを動かしてみましょう
    - for文・if文の書き方をなんとなく知りましょう
- [プログラムをimport](2_import)
    - caller.pyを動かしてみましょう
    - import文の基本的な使い方を知りましょう
        - importされて実行されるファイル側をモジュールといいます
- [importされた時とで挙動を分ける](3_name)
    - caller.pyを動かし、その後fizzbuzz.pyを動かしてみましょう
    - __name__という特殊な変数があることを知りましょう（他にもいろいろあります）
- [関数を定義する](4_def)
    - caller.pyを動かしてみましょう
    - caller.pyにかかれている、as構文・from構文の使い方をなんとなく知りましょう
    - fizzbuzz.pyにかかれているdef文による関数の宣言を覚えましょう
- [引数を利用する](5_args)
    - fizzbuzz.pyを動かしてみましょう
    - 関数への引数の与え方を知りましょう
    - 関数の引数・返り値の説明をするdocstring（"""で囲まれた部分）という文化があることを知りましょう
    - 変数の型を少し意識してみましょう
        - 35行目の`ret += str(num)`を単純に`ret += num`としたときにどうなるか知りましょう
    - 自分でcaller.pyのようなものを書いてみましょう
        - fizzbuzz.pyには`if __name__`文があり、caller.pyからは実行されないことを確かめましょう
            - `if __name__`以降をモジュールの使用方法の例示や単体テスト用に使うこともあります
        - floatの値を引数に入れてみましょう
- [オブジェクト指向](6_class)
    - 

## オブジェクト指向とは？
手続き（コード）とデータを切り分けるのではなく、一つのまとまったもの（オブジェクト）として捉えよう、という考え方。  
といってもなかなか意味がわからないので、簡単な例示を。  

- [手続き指向プログラミング](7_oop/procedual.py)
    - procedua.pyを動かしてみましょう
    - python2系で問題になる文字コードについて、明示する方法を知りましょう
    - 詳細はプログラム中のメモを読んでください
- [オブジェクト指向プログラミング](7_oop/object.py)
    - object.pyを動かしてみましょう
    - 手続き指向プログラミングとの違いを知りましょう
    - 詳細はプログラム中のメモを読んでください
- [classによるオブジェクト指向プログラミング](7_oop/animal.py)
    - animal.pyを動かしてみましょう
    - classを用いたオブジェクト指向プログラミングの良さを知りましょう
    - 詳細はプログラム中のメモを読んでください

オブジェクト指向というのはプログラムの書き方の問題なので、classだけを指すものではありません。  
もちろんclassというのはオブジェクト指向プログラミングをする上で強力なツールですが、間違った使い方をすればオブジェクト指向にはなりません。  

オブジェクト指向でのプログラミングは、設計と実装を切り分けやすい、処理が複雑になってもコードが複雑になりにくい、複数人での開発がしやすい、コードの使い回しがしやすい、といった利点があります。  
その反面、手続き指向で書かれたプログラムより遅くなりがち、メモリ使用量が増える、継承が増えすぎるとコードを追いにくくなる、といった欠点もあります。  
このあたりの欠点は使っていく中でわかっていきますが、プログラム規模が小さければそんなに気になることじゃあありません。  




